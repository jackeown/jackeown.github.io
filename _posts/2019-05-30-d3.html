---
layout: default
author: Jack
title: Playing Around with D3.js 
---

<script src="https://d3js.org/d3.v4.js"></script>

<script>
    // d for domain, r for range...
    function linearScale(d1,d2, r1, r2){
        function scale(x){
            let z = (x-d1)/(d2-d1)
            return z*(r2-r1) + r1;
        }
        return scale;
    }



    class LinePlot extends HTMLElement {
        static observedAttributes = ["data", "xmin", "xmax", "ymin", "ymax"];

        constructor() {
            // Always call super first in constructor
            super();
            
            // Set up canvas 
            this.shadow = this.attachShadow({mode: 'open'});
            this.canvas = document.createElement("canvas");
            this.canvas.setAttribute("style","background-color:rgb(240,240,250);box-shadow:0px 0px 10px -3px black;width:100%;height:100%;");
            this.ctx = this.canvas.getContext("2d");
            this.shadow.appendChild(this.canvas);
            

            this.DPISet = false;
            this.dpiInterval = setInterval(this.fixDPI.bind(this), 200);
            setTimeout(this.fixDPI.bind(this), 20);

            // config
            this.padding = 30;
        }

        attributeChangedCallback(name, oldValue, newValue) {
            console.log(`custom element attribute "${name}"!`);
            if(name === "data"){
                this.data = JSON.parse(this.getAttribute('data'));

                if(this.data == null){
                    this.xmin = this.xmax = this.ymin = this.ymax = null;
                    this.scaleX = this.scaleY = null;
                }
            }

            // Find a better way to do this...
            if(this.getAttribute("xmin")){
                this.xmin = +this.getAttribute("xmin")
            }
            else if(this.data){
                this.xmin = Math.min(...this.data.xs);
            }

            if(this.getAttribute("xmax")){
                this.xmax = +this.getAttribute("xmax")
            }
            else if(this.data){
                this.xmax = Math.max(...this.data.xs);
            }

            if(this.getAttribute("ymin")){
                this.ymin = +this.getAttribute("ymin")
            }
            else if(this.data){
                this.ymin = Math.min(...this.data.ys);
            }

            if(this.getAttribute("ymax")){
                this.ymax = +this.getAttribute("ymax")
            }
            else if(this.data){
                this.ymax = Math.max(...this.data.ys);
            }


            this.renderPlot();
        }


        fixDPI() {
            //the + prefix casts it to an integer
            //the slice method gets rid of "px"
            let style_height = +getComputedStyle(this.canvas).getPropertyValue("height").slice(0, -2);
            let style_width = +getComputedStyle(this.canvas).getPropertyValue("width").slice(0, -2);

            //scale the canvas
            if(this.canvas.height != style_height*window.devicePixelRatio ||
               this.canvas.width  != style_width*window.devicePixelRatio ){

                this.canvas.height = style_height * window.devicePixelRatio;
                this.canvas.width = style_width * window.devicePixelRatio;
                this.DPISet = true;
                this.renderPlot();
            }
        }


        renderPlot(){
            this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
            if(this.data != null && this.DPISet){
                this.scaleX = linearScale(this.xmin, this.xmax, this.padding, this.canvas.width-this.padding);
                this.scaleY = linearScale(this.ymin, this.ymax, this.canvas.height-this.padding, this.padding);
                this.scaleXInverse = linearScale(this.padding, this.canvas.width-this.padding, this.xmin, this.xmax);
                this.scaleYInverse = linearScale(this.canvas.height-this.padding, this.padding, this.ymin, this.ymax);

                this.ctx.strokeStyle="black;"
                this.ctx.lineWidth=2;

                this.drawAxes();
                this.drawLine();
            }
        }

        drawLabel(text, x, y, rotated){
            this.ctx.font = "11pt arial"
            if(rotated){
                this.ctx.translate(x,y);
                this.ctx.rotate(-Math.PI/2);

                this.ctx.fillText(text,0,0);
                
                this.ctx.rotate(Math.PI/2);
                this.ctx.translate(-x,-y);
            }
            else{
                this.ctx.fillText(text,x,y);
            }
        }

        drawAxes(){
            let xTicks = 10;
            let yTicks = 5;

            // draw the long lines.
            this.ctx.beginPath();
            this.ctx.moveTo(this.scaleX(this.xmin), this.scaleY(this.ymax));
            this.ctx.lineTo(this.scaleX(this.xmin), this.scaleY(this.ymin));
            this.ctx.lineTo(this.scaleX(this.xmax), this.scaleY(this.ymin));
            this.ctx.stroke();

            // draw the tick marks and labels.
            for(let x=1; x <= xTicks; x++){
                let position = (x/xTicks)*(this.canvas.width-2*this.padding)+this.padding;
                let zero = this.canvas.height-this.padding;
                this.ctx.beginPath();
                this.ctx.moveTo(position, zero+5);
                this.ctx.lineTo(position, zero-5);
                this.ctx.stroke();

                let label = (x/xTicks)*(this.xmax-this.xmin)+this.xmin;
                this.drawLabel(label.toFixed(2), position-15, zero+20, false);
            }
            for(let y=0; y < yTicks; y++){
                let position = (y/yTicks)*(this.canvas.height-2*this.padding)+this.padding;
                let zero = this.padding;
                this.ctx.beginPath();
                this.ctx.moveTo(zero-5, position);
                this.ctx.lineTo(zero+5, position);
                this.ctx.stroke();

                let label = ((yTicks-y)/yTicks)*(this.ymax-this.ymin)+this.ymin;
                this.drawLabel(label.toFixed(2), zero-10, position+15, true);
            }
        
        }

        drawLine(){
            this.ctx.beginPath();
            this.ctx.moveTo(this.scaleX(this.data.xs[0]), this.scaleY(this.data.ys[0]));
            for(let i=1; i<this.data.xs.length; i++){
                let x = this.scaleX(this.data.xs[i])
                let y = this.scaleY(this.data.ys[i])
                this.ctx.lineTo(x,y);
            }
            this.ctx.stroke();
        }

    }

    customElements.define('line-plot', LinePlot);

</script>


<div style="width:100%;height:300px;">
    <line-plot id="myPlot" ></line-plot>
</div>

<script>
step = 0;
data = {}
data.xs = [];
data.ys = [];
val = 0;
setInterval(function(){
    step++;

    lp = document.querySelector("#myPlot")
    val += Math.random()-0.5;
    data.xs.push(step);
    data.ys.push(val);

    lp.setAttribute("data", JSON.stringify(data))
},50);
</script>